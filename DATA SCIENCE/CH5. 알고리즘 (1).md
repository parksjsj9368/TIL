# CH5. 알고리즘 (1)

<br>

<br>

## 5.1 알고리즘이란

<br>

- 알고리즘 : 문제를 해결하는 절차

  ex) 정렬 알고리즘

  1. 보고 정렬 : 랜덤하게 섞다가 우연히 오름차순 정렬될 때까지 반복하는 방법
  2. 버블 정렬 : 2장의 카드를 뽑아서 내림차수능로 되어 있으면 오름차순으로 정렬한 뒤에 되돌리고, 그렇지 않으면 그대로 원래 위치로 되돌리는 절차를 반복하는 방법
  3. 삽입 정렬 : 카드 순서가 반드시 오름차순이 되도록 카드 한장씩 새로 배치해 가는 방법
  4. 병합 정렬 : 13장 카드를 2장씩 7개 그룹으로 나누고, 각 그룹을 오름차순으로 정렬. 후 다시 두 그룹씩 골라서 4장의 카드가 오름차순이 되도록 결합해 가는 방법
  5. 퀵 정렬 : 어떤 수를 기준으로 그 보다 큰 카드가 오른쪽, 작은 카드가 왼쪽에 오도록 바꾸는 동작을 반복하는 방법

이처럼 한 가지 문제에 대해서도 다양한 해결법이 존재한다

<br>

<br>

## 5.2 시간 복잡도

<br>

- 좋은 알고리즘 : '가장 빠르고 최대한 메모리를 낭비하지 않는 알고리즘'

<br>

- 시간 복잡도 : 처리에 걸리는 시간

- 공간 복잡도 : 필요한 메모리 영역

최선, 평균, 최악 시간 복잡도를 보고 알고리즘을 평가한다

<br>

<br>

## 5.3 빅오 표기법

<br>

- 빅오 표기법 : 복잡도를 근사적으로 평가한다

  ex) 상수 O(1), 선형 O(n), 준선형 O(nlogn), 제곱 O(n^2), 지수 O(2^n), 계승 O(n!) 등

<br>

<br>

## 5.4 기초적인 복잡도 계산

<br>

```python
# 시간 복잡도 O(n)
for i in range(n):
    print(v[i])
    

# 시간 복잡도 O(n^2)
for i in range(n):
    for j in range(n):
        print(v[i,j])
        
       
# 시간 복잡도 O(log_2 n)
# 이진탐색 : 오름차순으로 정렬된 단어 목록에서 목적 단어가 몇번째 있는지 탐색 알고리즘
# 목록 한가운데 있는 단어와 목적 단어를 비교해 목적 단어가 뒤쪽에 있다면 후반 부분만 남긴다
# 다음으로 그 후반 부분에서 정중앙에 있는 단어와 비교해서 다시 전반이나 후반을 남기는 방법을 반복한다
```

<br>

<br>

## 5.5 데이터 구조의 복잡도

<br>

- 이름, 출신지의 테이블1과 이름, 나이의 테이블2를 결합하려고 한다
- 배열과 딕셔너리(key-value) 중 어떤 알고리즘의 시간 복잡도가 빠를까?

<br>

- 배열

1. 2개의 배열로 나열해 저장

2. 시간 복잡도  = m(테이블1의 길이) * n(테이블2의 길이) = O(mn)

- 딕셔너리(key-value)

1. 키를 이름으로, 값을 나이로 해서 저장
2. 시간 복잡도  = O(m)

<br>